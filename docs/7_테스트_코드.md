# 7. 테스트 코드 작성 (23강 ~ 25강)

이 문서는 **결함 없는 소프트웨어**를 만들기 위한 필수 과정인 **단위 테스트(Unit Test)**와 **통합 테스트(Integration Test)** 방법을 다룹니다.
Spring 환경에서 **JUnit**과 **Mockito**를 활용하여 효율적으로 테스트하는 방법을 학습합니다.

---

## 1. 테스트의 중요성 및 JUnit 기초 (23강)

"코드가 내 컴퓨터에서는 잘 돌아가는데?" 라는 말은 통하지 않습니다.
테스트 코드는 **내가 짠 코드가 의도대로 동작하는지 검증**하고, **리팩토링 시 사이드 이펙트를 방지**하는 안전장치입니다.

### 1.1 라이브러리 추가 (`pom.xml`)

전자정부 프레임워크 3.10은 기본적으로 JUnit 4를 지원하지만, 최신 트렌드인 **JUnit 5 (Jupiter)** 사용을 권장합니다.

```xml
<!-- JUnit 4 (레거시) -->
<!--
<dependency>
    <groupId>junit</groupId>
    <artifactId>junit</artifactId>
    <version>4.13.2</version>
    <scope>test</scope>
</dependency>
-->

<!-- JUnit 5 (추천) -->
<dependency>
    <groupId>org.junit.jupiter</groupId>
    <artifactId>junit-jupiter-api</artifactId>
    <version>5.8.2</version>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>org.junit.jupiter</groupId>
    <artifactId>junit-jupiter-engine</artifactId>
    <version>5.8.2</version>
    <scope>test</scope>
</dependency>
```

### 1.2 JUnit 5 주요 어노테이션

*   `@Test`: 테스트 메소드임을 명시.
*   `@BeforeEach`: 각 테스트 실행 **전**에 매번 실행 (초기화).
*   `@AfterEach`: 각 테스트 실행 **후**에 매번 실행 (정리).
*   `@DisplayName`: 테스트 이름을 읽기 쉽게 지정.

### 1.3 기본 테스트 예제

```java
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.*;

class CalculatorTest {

    Calculator calc;

    @BeforeEach
    void setUp() {
        calc = new Calculator(); // 테스트 전 객체 생성
    }

    @Test
    @DisplayName("더하기 테스트")
    void testAdd() {
        int result = calc.add(10, 20);
        
        // Assertions.assertEquals(기대값, 실제값, "실패 시 메시지");
        assertEquals(30, result, "10 + 20은 30이어야 합니다.");
    }
}
```

---

## 2. Mockito를 이용한 Service 테스트 (24강)

Service 계층을 테스트할 때, **DB(DAO)까지 실제로 갔다면 그것은 단위 테스트가 아닙니다.**
**Mockito**를 사용하여 DAO가 "가짜로(Mock)" 동작하게 만들어, 오직 Service 로직에만 집중해야 합니다.

### 2.1 라이브러리 추가 (`pom.xml`)
```xml
<dependency>
    <groupId>org.mockito</groupId>
    <artifactId>mockito-core</artifactId>
    <version>4.5.1</version>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>org.mockito</groupId>
    <artifactId>mockito-junit-jupiter</artifactId>
    <version>4.5.1</version>
    <scope>test</scope>
</dependency>
```

### 2.2 Service 테스트 코드 (`UserServiceTest.java`)

```java
@ExtendWith(MockitoExtension.class) // Mockito 활성화
class UserServiceTest {

    @InjectMocks // 가짜 DAO를 주입받을 "진짜" Service
    UserServiceImpl userService;

    @Mock // 가짜로 만들 DAO
    UserDAO userDAO;

    @Test
    @DisplayName("회원가입 로직 검증")
    void testInsertUser() throws Exception {
        // given (준비)
        UserVO user = new UserVO();
        user.setId("testUser");
        
        // DAO는 아무 일도 안 하도록 설정 (void 메소드인 경우)
        // 만약 리턴이 있다면: given(userDAO.selectUser(any())).willReturn(null);
        
        // when (실행)
        userService.insertUser(user);

        // then (검증)
        // 1. DAO의 insertUser가 딱 1번 호출되었는지 확인
        verify(userDAO, times(1)).insertUser(any(UserVO.class));
    }
}
```

---

## 3. Controller 테스트 (MockMvc) (25강)

브라우저 없이 Controller URL을 호출하고, 결과(View, Model)를 검증하는 방법입니다.

### 3.1 테스트 설정
**Spring Test** 라이브러리가 필요합니다.

```java
@ExtendWith(SpringExtension.class) // Spring Context 사용
@ContextConfiguration(locations = {
    "file:src/main/resources/egovframework/spring/context-*.xml", 
    "file:src/main/webapp/WEB-INF/config/egovframework/springmvc/egov-com-servlet.xml"
})
@WebAppConfiguration
class BoardControllerTest {

    @Autowired
    private WebApplicationContext wac;

    private MockMvc mockMvc; // 브라우저 역할을 하는 가짜 객체

    @BeforeEach
    void setup() {
        // MockMvc 초기화
        this.mockMvc = MockMvcBuilders.webAppContextSetup(wac).build();
    }

    @Test
    @DisplayName("게시판 목록 조회 URL 테스트")
    void testList() throws Exception {
        mockMvc.perform(get("/boardList.do")           // 1. GET 요청
                .param("pageIndex", "1"))              // 파라미터 전달
                
                .andExpect(status().isOk())            // 2. 상태코드 200(OK) 확인
                
                .andExpect(view().name("board/list"))  // 3. 리턴된 JSP 이름 확인
                
                .andExpect(model().attributeExists("resultList")) // 4. Model에 데이터가 있는지 확인
                
                .andDo(print());                       // 5. 로그 출력
    }
}
```

---

## 4. TDD (Test Driven Development) 개발 방식

**"테스트를 먼저 작성하고, 코드를 구현해라."**

1.  **RED (실패)**: 실패하는 테스트 코드를 먼저 짭니다. (아직 기능 구현이 안 됐으니까 당연히 에러)
2.  **GREEN (성공)**: 테스트를 통과할 만큼만 최소한의 코드를 작성합니다.
3.  **REFACTOR (개선)**: 중복을 제거하고 코드를 깔끔하게 다듬습니다. (테스트가 있으니 안심하고 수정!)

---

### 요약
1.  **JUnit 5**: `@Test`, `@BeforeEach` 등을 사용해 테스트 구조를 잡는다.
2.  **Mockito**: Service 테스트 시 DAO를 가짜(`@Mock`)로 만들어 DB 없이 로직만 검증한다.
3.  **MockMvc**: Controller 테스트 시 브라우저 없이 HTTP 요청을 보내고 응답을 확인한다.
4.  **효과**: 버그가 획기적으로 줄어들고, 유지보수 시 두려움이 사라집니다.
