# 4. 실전! 계층형 게시판 (10강 ~ 13강)

이 문서는 **계층형 게시판(답글 기능 포함)**을 처음부터 끝까지 구현하는 과정을 다룹니다.
DB 설계부터 답글 로직, 수정/삭제, 페이징까지 **실무 수준의 코드**를 포함하고 있습니다.

---

## 1. DB 테이블 설계 (10강)

계층형 게시판의 핵심은 **"어떤 글이 어떤 글의 답글인가?"**를 표현하는 것입니다. 이를 위해 3가지 핵심 컬럼이 필요합니다.

### 1.1 핵심 컬럼 설명
1.  **GROUP_NUM (그룹 번호)**: "어느 가족인가?"
    *   원글과 그 원글에 달린 모든 답글들은 같은 `GROUP_NUM`을 가집니다.
    *   원글의 `BORDER_ID`와 같습니다.
2.  **GROUP_ORDER (그룹 내 순서)**: "가족 내에서 몇 번째인가?"
    *   원글은 `0`번입니다.
    *   답글이 달릴 때마다 `1, 2, 3...`으로 늘어납니다.
    *   **중요**: 새 답글이 달리면, 기존에 있던 동생들(순서가 뒤인 글들)은 한 칸씩 뒤로 밀려납니다.
3.  **GROUP_TAB (들여쓰기 레벨)**: "몇 대손인가?"
    *   원글: `0` (들여쓰기 없음)
    *   답글: `1` (RE:)
    *   답글의 답글: `2` (RE: RE:)

### 1.2 PostgreSQL 테이블 생성 쿼리 (`EGOV_BBS`)
```sql
CREATE TABLE EGOV_BBS (
    BOARD_ID       SERIAL PRIMARY KEY,      -- 게시글 고유 번호 (자동증가)
    BOARD_TYPE     VARCHAR(1) DEFAULT 'A',  -- 게시판 타입 (A:일반, B:공지 등)
    
    -- [핵심] 계층형 게시판을 위한 컬럼 3대장
    GROUP_NUM      INTEGER DEFAULT 0,       -- 그룹 번호
    PARENT_ID      INTEGER DEFAULT 0,       -- 부모 글 번호 (참조용)
    GROUP_ORDER    INTEGER DEFAULT 0,       -- 그룹 내 순서
    GROUP_TAB      INTEGER DEFAULT 0,       -- 들여쓰기 레벨
    
    USER_ID        VARCHAR(255),            -- 작성자 ID
    NICKNAME       VARCHAR(255),            -- 작성자 닉네임
    WRITE_DAY      TIMESTAMP DEFAULT NOW(), -- 작성일
    WRITER_IP      VARCHAR(16),             -- 작성자 IP
    
    TITLE          VARCHAR(100),            -- 제목
    BOARD_TEXT     TEXT,                    -- 내용 (긴 글)
    SEE_COUNT      INTEGER DEFAULT 0,       -- 조회수
    
    FILENAME       VARCHAR(250),            -- 첨부파일 이름
    FILEURL        VARCHAR(250),            -- 첨부파일 경로
    REPLY_COUNT    INTEGER DEFAULT 0        -- 댓글 수
);
```

---

## 2. 글쓰기 및 목록 조회 (10강)

### 2.1 원글 작성 (INSERT)
원글은 부모가 없으므로, **자신의 ID(`BORDER_ID`)를 `GROUP_NUM`으로 가집니다.**

**Mapper XML**
```xml
<insert id="insertBoard" parameterType="boardVO">
    <!-- 1. 시퀀스에서 다음 번호를 미리 가져옴 (PostgreSQL 방식) -->
    <selectKey keyProperty="boardId" resultType="int" order="BEFORE">
        SELECT nextval('egov_bbs_board_id_seq')
    </selectKey>

    INSERT INTO EGOV_BBS (
        BOARD_ID, GROUP_NUM, GROUP_ORDER, GROUP_TAB,
        USER_ID, NICKNAME, TITLE, BOARD_TEXT, WRITE_DAY
    ) VALUES (
        #{boardId},
        #{boardId},  -- [중요] 원글은 자기 번호가 곧 그룹 번호
        0,            -- 원글 순서는 0
        0,            -- 원글 들여쓰기는 0
        #{userId}, #{nickname}, #{title}, #{boardText}, NOW()
    )
</insert>
```

### 2.2 목록 조회 (SELECT)
정렬 순서가 매우 중요합니다.
1.  **`GROUP_NUM DESC`**: 최신 가족(최신 원글)이 가장 위에 와야 합니다.
2.  **`GROUP_ORDER ASC`**: 같은 가족 내에서는 형(원글) -> 동생(답글) 순서로 나와야 합니다.

**Mapper XML**
```xml
<select id="selectBoardList" resultType="egovMap">
    SELECT
        BOARD_ID, TITLE, NICKNAME, WRITE_DAY, SEE_COUNT,
        GROUP_TAB  -- 화면에서 들여쓰기(RE:) 표현을 위해 필요
    FROM EGOV_BBS
    ORDER BY
        GROUP_NUM DESC,
        GROUP_ORDER ASC
</select>
```

---

## 3. 답글 달기 로직 (11강) - **가장 중요!**

답글을 달 때는 **부모 글의 정보**(`GROUP_NUM`, `GROUP_ORDER`, `GROUP_TAB`)를 기준으로 내 자리를 찾습니다.

### 3.1 로직 순서
1.  **자리 확보 (UPDATE)**: 같은 그룹(`GROUP_NUM`) 안에서, 나보다 늦게 온 애들(`GROUP_ORDER`가 부모보다 큰 애들)의 순서를 `+1` 해서 뒤로 밉니다.
2.  **답글 저장 (INSERT)**:
    *   `GROUP_NUM`: 부모와 동일 (같은 가족)
    *   `GROUP_ORDER`: 부모 + 1 (부모 바로 다음)
    *   `GROUP_TAB`: 부모 + 1 (한 칸 더 들여쓰기)

### 3.2 구현 코드 (Mapper XML)

**1) 자리 확보 (UPDATE)**
```xml
<update id="updateOtherReply" parameterType="boardVO">
    UPDATE EGOV_BBS
    SET GROUP_ORDER = GROUP_ORDER + 1
    WHERE GROUP_NUM = #{groupNum}    -- 같은 가족 중에서
      AND GROUP_ORDER > #{groupOrder} -- 부모보다 뒤에 있는 애들만
</update>
```

**2) 답글 저장 (INSERT)**
```xml
<insert id="insertBoardReply" parameterType="boardVO">
    INSERT INTO EGOV_BBS (
        BOARD_ID, GROUP_NUM, GROUP_ORDER, GROUP_TAB,
        USER_ID, TITLE, ...
    ) VALUES (
        nextval('egov_bbs_board_id_seq'),
        #{groupNum},       -- 부모 그룹 번호 그대로
        #{groupOrder} + 1, -- 부모 순서 + 1
        #{groupTab} + 1,   -- 부모 들여쓰기 + 1
        #{userId}, #{title}, ...
    )
</insert>
```

**3) Service (트랜잭션 필수)**
```java
@Transactional
public void insertReply(BoardVO vo) {
    boardDAO.updateOtherReply(vo); // 자리 비켜!
    boardDAO.insertBoardReply(vo); // 내 자리 찜!
}
```

---

## 4. 수정 및 삭제 (12강)

### 4.1 수정 (UPDATE)
반드시 **작성자 본인(`USER_ID`)**인지 확인해야 합니다.

```xml
<update id="updateBoard">
    UPDATE EGOV_BBS
    SET TITLE = #{title}, BOARD_TEXT = #{boardText}
    WHERE BOARD_ID = #{boardId}
      AND USER_ID = #{userId}  -- [보안] 본인 확인
</update>
```

### 4.2 삭제 (논리적 삭제)
계층형 게시판에서 원글을 지운다고 답글까지 다 지우면 안 됩니다. (답글 쓴 사람은 억울하니까요)
그래서 **내용만 "삭제된 글입니다"로 바꾸는 방식(Update)**을 사용합니다.

```xml
<update id="deleteBoard">
    UPDATE EGOV_BBS
    SET
        TITLE = '삭제된 글입니다.',
        BOARD_TEXT = '',
        USER_ID = '',       -- 개인정보 삭제
        NICKNAME = '알수없음'
    WHERE BOARD_ID = #{boardId}
      AND USER_ID = #{userId}
</update>
```

---

## 5. 페이징 처리 (13강)

게시글이 많을 때 페이지를 나누는 방법입니다.

### 5.1 Controller (`PaginationInfo`)
전자정부 프레임워크가 제공하는 유틸리티 클래스입니다.

```java
PaginationInfo paginationInfo = new PaginationInfo();
paginationInfo.setCurrentPageNo(pageIndex); // 현재 페이지 (예: 1)
paginationInfo.setRecordCountPerPage(10);   // 한 페이지에 10개
paginationInfo.setPageSize(5);              // 페이지 번호 5개 (1~5)

// 계산된 값을 VO에 넣어서 쿼리로 전달
searchVO.setFirstIndex(paginationInfo.getFirstRecordIndex());
searchVO.setRecordCountPerPage(paginationInfo.getRecordCountPerPage());
```

### 5.2 Mapper XML (PostgreSQL `LIMIT/OFFSET`)
Oracle의 복잡한 `ROWNUM` 대신 `LIMIT`과 `OFFSET`을 사용합니다.

```xml
<select id="selectBoardList" ...>
    SELECT ...
    FROM EGOV_BBS
    ORDER BY GROUP_NUM DESC, GROUP_ORDER ASC
    
    -- [핵심] 페이징 쿼리
    LIMIT #{recordCountPerPage}  -- 10개 가져와
    OFFSET #{firstIndex}         -- 앞에서부터 몇 개 건너뛰고
</select>
```

### 5.3 JSP (`ui:pagination`)
```jsp
<!-- 페이징 버튼 자동 생성 -->
<ui:pagination paginationInfo="${paginationInfo}" type="image" jsFunction="fn_link_page"/>
```

---

### 요약
이 문서는 **계층형 게시판의 바이블**과 같습니다.
1.  **DB**: `GROUP_` 3형제로 계층 구조를 잡는다.
2.  **답글**: `UPDATE`로 자리를 만들고 `INSERT`로 들어간다.
3.  **삭제**: `DELETE` 대신 `UPDATE`로 흔적을 남긴다.
4.  **페이징**: `LIMIT/OFFSET`으로 필요한 만큼만 가져온다.
