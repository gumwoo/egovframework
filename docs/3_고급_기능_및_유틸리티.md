# 3. 고급 기능 및 유틸리티 (8강 ~ 9강)

이 문서는 개발의 필수 요소인 **로깅(Logging)**과 공통 기능을 효율적으로 관리하는 **AOP(관점 지향 프로그래밍)**에 대해 다룹니다.

---

## 1. 로깅 (Logging) - Log4j2 (8강)

`System.out.println()`은 성능을 저하시키고 관리가 불가능합니다. 실무에서는 반드시 로깅 라이브러리를 사용해야 합니다.

### 1.1 라이브러리 추가 (`pom.xml`)
전자정부 프레임워크 3.10 이상은 기본적으로 Log4j2를 지원합니다.

```xml
<dependency>
    <groupId>org.apache.logging.log4j</groupId>
    <artifactId>log4j-core</artifactId>
    <version>2.17.1</version>
</dependency>
<dependency>
    <groupId>org.apache.logging.log4j</groupId>
    <artifactId>log4j-slf4j-impl</artifactId>
    <version>2.17.1</version>
</dependency>
```

### 1.2 설정 파일 (`src/main/resources/log4j2.xml`)
로그를 **어디에(Appender)**, **어떤 레벨(Level)**로 남길지 정의합니다.

```xml
<?xml version="1.0" encoding="UTF-8"?>
<Configuration>
    <Appenders>
        <!-- 1. 콘솔 출력 -->
        <Console name="console" target="SYSTEM_OUT">
            <PatternLayout pattern="%d{yyyy-MM-dd HH:mm:ss} %-5p [%c] %m%n" />
        </Console>

        <!-- 2. 파일 저장 (RollingFile: 일정 크기/시간마다 파일 교체) -->
        <RollingFile name="file" fileName="C:/logs/app.log"
                     filePattern="C:/logs/app-%d{yyyy-MM-dd}.log">
            <PatternLayout pattern="%d %-5p [%c] %m%n" />
            <Policies>
                <TimeBasedTriggeringPolicy /> <!-- 매일 새 파일 -->
                <SizeBasedTriggeringPolicy size="10MB" /> <!-- 10MB 넘으면 새 파일 -->
            </Policies>
        </RollingFile>
    </Appenders>

    <Loggers>
        <!-- 내 프로젝트는 DEBUG 레벨부터 다 찍어라 -->
        <Logger name="egovframework" level="DEBUG" additivity="false">
            <AppenderRef ref="console" />
            <AppenderRef ref="file" />
        </Logger>

        <!-- 나머지는 INFO 레벨부터 -->
        <Root level="INFO">
            <AppenderRef ref="console" />
            <AppenderRef ref="file" />
        </Root>
    </Loggers>
</Configuration>
```

### 1.3 자바 코드 사용법
`slf4j` 인터페이스를 사용하는 것이 표준입니다.

```java
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@Controller
public class SampleController {

    // 로거 객체 생성
    private static final Logger LOGGER = LoggerFactory.getLogger(SampleController.class);

    @RequestMapping("/list.do")
    public String list() {
        
        LOGGER.info("목록 조회 요청이 들어왔습니다."); // 정보성 로그
        
        try {
            // ... 로직 ...
            LOGGER.debug("DB 조회 결과: 5건"); // 개발용 상세 로그
        } catch (Exception e) {
            LOGGER.error("조회 중 에러 발생!", e); // 에러 로그 (예외 객체 e를 같이 넘김)
        }
        
        return "sample/list";
    }
}
```

---

## 2. AOP (Aspect Oriented Programming) (9강)

**"관점 지향 프로그래밍"**입니다. 핵심 비즈니스 로직(Service)과 공통 기능(로그, 보안, 트랜잭션)을 분리하는 기술입니다.

### 2.1 핵심 용어
*   **Aspect (관점)**: 공통 기능 그 자체 (예: 로그 찍기 기능).
*   **Pointcut (적용 지점)**: 어디에 적용할지 (예: `Service`의 모든 메소드).
*   **Advice (시점)**: 언제 실행할지 (예: 메소드 시작 전 `Before`, 끝난 후 `After`).

### 2.2 구현 방법 1: XML 기반 (고전적 방식)
설정 파일에 일일이 명시하는 방식입니다.

```xml
<!-- 공통 기능을 가진 클래스 빈 등록 -->
<bean id="logAop" class="egovframework.example.cmmn.LogAop" />

<aop:config>
    <!-- Pointcut: ServiceImpl로 끝나는 클래스의 모든 메소드 -->
    <aop:pointcut id="allService" expression="execution(* egovframework.example..impl.*Impl.*(..))" />

    <aop:aspect ref="logAop">
        <!-- 메소드 실행 전에 logAop의 printLog 실행 -->
        <aop:before pointcut-ref="allService" method="printLog" />
    </aop:aspect>
</aop:config>
```

### 2.3 구현 방법 2: 어노테이션 기반 (최신 방식 - 추천)
자바 코드에 `@Aspect`를 붙여서 처리합니다.

**설정 파일 (`context-aspect.xml`)**
```xml
<!-- 어노테이션 AOP 활성화 -->
<aop:aspectj-autoproxy />
<bean id="logAop" class="egovframework.example.cmmn.LogAop" />
```

**자바 파일 (`LogAop.java`)**
```java
@Aspect // "나 AOP야!"
@Component
public class LogAop {

    // Pointcut 정의
    @Pointcut("execution(* egovframework.example..impl.*Impl.*(..))")
    public void servicePointcut() {}

    // Advice: 메소드 시작 전
    @Before("servicePointcut()")
    public void beforeLog(JoinPoint joinPoint) {
        String methodName = joinPoint.getSignature().getName();
        System.out.println(">>> [AOP] " + methodName + " 메소드 시작!");
    }
    
    // Advice: 메소드 종료 후 (에러가 나도 실행됨)
    @After("servicePointcut()")
    public void afterLog() {
        System.out.println(">>> [AOP] 메소드 종료.");
    }
}
```

### 2.4 AOP의 효과
개발자는 비즈니스 로직(`insert`, `update`)만 작성하면 됩니다. 로그나 트랜잭션 코드를 매번 복사/붙여넣기 할 필요가 없어집니다.

**개발자가 작성한 코드:**
```java
public void insertBoard(BoardVO vo) {
    boardDAO.insertBoard(vo);
}
```

**실제 실행되는 모습 (AOP 적용 시):**
```text
>>> [AOP] insertBoard 메소드 시작!  <-- 자동 실행
(DB 저장 수행)
>>> [AOP] 메소드 종료.              <-- 자동 실행
```

---

### 요약
1.  **로깅**: `log4j2.xml`로 설정하고 `LOGGER.info()`로 남긴다. 에러는 `LOGGER.error()`로 스택트레이스까지 남긴다.
2.  **AOP**: 반복되는 코드를 걷어내는 기술이다.
3.  **방식**: XML 방식보다 `@Aspect` 어노테이션 방식이 더 직관적이고 많이 쓰인다.
