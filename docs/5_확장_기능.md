# 5. 확장 기능 (14강 ~ 17강)

이 문서는 웹 애플리케이션의 완성도를 높이는 **파일 처리**, 데이터 무결성을 위한 **트랜잭션**, 그리고 비동기 통신을 위한 **Ajax(JSON, XML)** 기술을 다룹니다.

---

## 1. 파일 업로드 및 다운로드 (14강)

### 1.1 라이브러리 및 설정
파일 처리를 위해 `commons-io`, `commons-fileupload` 라이브러리가 필요하며, Spring에 `MultipartResolver`를 등록해야 합니다.

**pom.xml**
```xml
<dependency>
    <groupId>commons-io</groupId>
    <artifactId>commons-io</artifactId>
    <version>2.11.0</version>
</dependency>
<dependency>
    <groupId>commons-fileupload</groupId>
    <artifactId>commons-fileupload</artifactId>
    <version>1.5</version>
</dependency>
```

**context-common.xml**
```xml
<!-- 파일 업로드 처리기 (ID는 반드시 multipartResolver여야 함) -->
<bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver">
    <property name="maxUploadSize" value="100000000" /> <!-- 100MB -->
    <property name="maxInMemorySize" value="100000000" />
</bean>
```

### 1.2 파일 업로드 (Controller)
`MultipartHttpServletRequest`를 사용하여 파일을 받습니다.

```java
@RequestMapping("/borderInsert.do")
public String insert(MultipartHttpServletRequest multiRequest, @ModelAttribute BorderVO vo) throws Exception {
    
    // 1. 파일 꺼내기
    Map<String, MultipartFile> files = multiRequest.getFileMap();
    String uploadPath = "C:/uploads/";

    Iterator<Entry<String, MultipartFile>> itr = files.entrySet().iterator();
    while (itr.hasNext()) {
        Entry<String, MultipartFile> entry = itr.next();
        MultipartFile file = entry.getValue();

        if (!file.isEmpty()) {
            // 2. 파일 저장 (UUID로 중복 방지)
            String saveName = UUID.randomUUID().toString() + "_" + file.getOriginalFilename();
            file.transferTo(new File(uploadPath + saveName));

            // 3. VO에 정보 세팅
            vo.setFilename(file.getOriginalFilename());
            vo.setFileurl(saveName);
        }
    }
    // DB 저장 로직 호출...
    return "redirect:/list.do";
}
```

### 1.3 이미지 보기/다운로드 (Controller)
저장된 파일을 읽어서 바이트 배열(`byte[]`)로 응답합니다.

```java
@RequestMapping("/imageView.do")
public ResponseEntity<byte[]> imageView(@RequestParam("file") String fileName) throws Exception {
    File file = new File("C:/uploads/" + fileName);
    InputStream in = new FileInputStream(file);
    
    // 파일을 바이트 배열로 변환 (IOUtils 사용)
    byte[] imageBytes = IOUtils.toByteArray(in);
    in.close();

    HttpHeaders headers = new HttpHeaders();
    headers.setContentType(MediaType.IMAGE_JPEG); // 이미지 타입 지정

    return new ResponseEntity<>(imageBytes, headers, HttpStatus.OK);
}
```

---

## 2. 트랜잭션 (Transaction) (15강)

**"All or Nothing"**. 여러 작업이 모두 성공하거나, 하나라도 실패하면 모두 취소(`Rollback`)되어야 합니다.

### 2.1 AOP 기반 설정 (`context-transaction.xml`)
Service의 모든 메소드에 트랜잭션을 자동으로 적용하는 방법입니다. (가장 많이 사용)

```xml
<!-- 트랜잭션 매니저 -->
<bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
    <property name="dataSource" ref="dataSource"/>
</bean>

<!-- 트랜잭션 규칙 -->
<tx:advice id="txAdvice" transaction-manager="txManager">
    <tx:attributes>
        <tx:method name="select*" read-only="true"/> <!-- 조회는 읽기 전용 -->
        <tx:method name="*" rollback-for="Exception"/> <!-- 나머지는 에러 시 롤백 -->
    </tx:attributes>
</tx:advice>

<!-- AOP 적용 -->
<aop:config>
    <aop:pointcut id="requiredTx" expression="execution(* egovframework..impl.*Impl.*(..))"/>
    <aop:advisor advice-ref="txAdvice" pointcut-ref="requiredTx" />
</aop:config>
```

### 2.2 어노테이션 기반 (`@Transactional`)
특정 메소드에만 트랜잭션을 걸고 싶을 때 사용합니다.

```java
@Service
public class BorderServiceImpl {
    
    @Transactional(rollbackFor = Exception.class)
    public void insertReply(BorderVO vo) {
        dao.updateOtherReply(vo); // 1. 자리 비키기
        dao.insertReply(vo);      // 2. 내 자리 들어가기
        // 둘 중 하나라도 에러 나면 둘 다 취소됨
    }
}
```

---

## 3. Ajax - JSON (16강)

화면 깜빡임 없이 데이터를 주고받는 표준 방식입니다.

### 3.1 라이브러리 및 설정
`Jackson` 라이브러리가 자바 객체를 JSON 문자열로 바꿔줍니다.

**pom.xml**
```xml
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-databind</artifactId>
    <version>2.13.4</version>
</dependency>
```

### 3.2 Controller (`@ResponseBody`)
```java
@RequestMapping(value = "/getJson.do", produces = "application/json; charset=utf8")
@ResponseBody // JSP가 아니라 데이터를 리턴하겠다는 의미
public Map<String, Object> getJson() {
    Map<String, Object> map = new HashMap<>();
    map.put("status", "success");
    map.put("message", "JSON 데이터입니다.");
    return map; // -> {"status":"success", "message":"JSON 데이터입니다."} 로 변환됨
}
```

### 3.3 Client (jQuery)
```javascript
$.ajax({
    url: "getJson.do",
    type: "POST",
    dataType: "json", // 받을 데이터 타입
    success: function(data) {
        alert(data.message); // "JSON 데이터입니다." 출력
    }
});
```

---

## 4. Ajax - XML (17강)

레거시 시스템이나 공공 데이터 연동 시 사용합니다.

### 4.1 라이브러리 (JDOM)
XML 문서를 생성하고 파싱하기 위해 필요합니다.

**pom.xml**
```xml
<dependency>
    <groupId>org.jdom</groupId>
    <artifactId>jdom2</artifactId>
    <version>2.0.6</version>
</dependency>
```

### 4.2 Controller (수동 생성)
```java
@RequestMapping("/getXml.do")
public void getXml(HttpServletResponse response) throws Exception {
    // <Root><Item>내용</Item></Root> 형태 만들기
    Element root = new Element("Root");
    Element item = new Element("Item");
    item.setText("내용");
    root.addContent(item);

    Document doc = new Document(root);
    
    response.setContentType("text/xml; charset=UTF-8");
    new XMLOutputter().output(doc, response.getWriter());
}
```

### 4.3 Client (jQuery Parsing)
```javascript
$.ajax({
    url: "getXml.do",
    dataType: "xml",
    success: function(xml) {
        // find()로 태그를 찾아서 값 추출
        var text = $(xml).find("Item").text();
        alert(text); // "내용" 출력
    }
});
```

---

### 요약
1.  **파일**: `MultipartResolver` 설정 필수, `enctype="multipart/form-data"` 주의.
2.  **트랜잭션**: 데이터 정합성을 위해 필수. AOP 설정 한 번이면 편하다.
3.  **Ajax**:
    *   **JSON**: `@ResponseBody` + Jackson (가장 많이 씀).
    *   **XML**: JDOM으로 직접 생성 + jQuery `find()`로 파싱.
